// define ON and OFF as two states
enum State {ON, OFF};
State state = OFF;

//define constants and pins
int motor_gate_pin = 5; // sends certain PWM to mosfet to control motor
int comparator_pin = 2; // recieves voltage signal information from comparator

volatile int comparator_counter = 0; // counter, needs to be declared volatile
// so compiler won't optimize the incrementing line out of the compiled program
// volatile is qualifier for interrupts specifically
// counter is interrupt-safe

int comparator_counter_previous = 0;
float current_time = 0; // time--> calls millis() which gives milliseconds since last reset
// check out elapsedmillis library for timing purposes
 
float comparator_time = 0; // current time
float comparator_time_previous = 0; // last time we reported the speed (# interrupts/time passed)
float comparator_time_delta = 0; // encoder_time - encoder_time_previous

// scaling factor from counts to rpm of motor (with gears taken into account)
int comparator_sample_interval = 1000; //how long (in ms) we wait before checking speed 

//define variables
//analog input + pwm variables
float duration = 0;
float start_time = 0;
float write_duty = 55; // duty cycle to send to mosfet to run motor (PWM)
float frequency = 0;
float angular_velocity = 0;
float PPR = 2;

float set_RPM = 0;
float measured_RPM = 0;
float new_RPM = 0;
float error = 0;
float max_RPM = 1648;

float Kp = 0.015;
float k = 0;

char tmp_str[7]; // temporary variable used in convert function

//interrupt service routine
// quick, called after each interrupt signal
void comparatorInterruptHandler() {
  ++comparator_counter;
}

void setup() {
  pinMode(motor_gate_pin, OUTPUT);
  // pinMode(comparator_power_pin, OUTPUT);
  // pinMode(LED_power_pin, OUTPUT);
  pinMode(comparator_pin, INPUT_PULLUP); // must be on pullup because encoder stays floating (locked at 5 from arduino) unless sensor is triggered (allows pin to be pulled down to 0)
  
  Serial.begin(9600);
  while (!Serial);  // wait until the serial monitor is open before proceeding
  Serial.println("Please enter desired motor speed in RPM: ");

  attachInterrupt(digitalPinToInterrupt(comparator_pin),comparatorInterruptHandler,RISING); // triggered when every 
  current_time = millis();
}

void loop() {
  if (state == OFF) {
    analogWrite(motor_gate_pin, 0);
    if(Serial.available()>0){
      set_RPM = Serial.parseInt();
      Serial.println((String)"Target RPM: "+set_RPM);
      Serial.println((String)"Enter desired centrifugation time in seconds: ");
      while (Serial.available()==0);
      duration = Serial.parseInt();
      Serial.println((String)"Centrifugation time: "+duration+" seconds");
      duration *= 1000; // convert to millis
      start_time = millis();
      state = ON; // now turned on!
    } else {
      Serial.println("Please enter desired motor speed in RPM: ");
      while (Serial.available()==0);
    }
  }
  if (state == ON) {
    current_time = millis();
    if ((current_time - start_time) > duration) {
      analogWrite(motor_gate_pin, 0);
      Serial.println("Centrifugation period finished. Ramp down initiated.");
      float comparator_counter_current = comparator_counter;
      delay(100);
      while (comparator_counter > comparator_counter_current) {
        comparator_counter_current = comparator_counter;
        delay(100);
      }
      Serial.println("Ramp down completed. Thank you for using our centrifuge!");
      state = OFF;
    }
    
    new_RPM = set_RPM;
    if (measured_RPM > 0) { // only starts reading this code once centrifugation starts
      error = set_RPM - measured_RPM;
      if (error > 0) {
        k = -(error*Kp);
      } else if (error < 0) {
        k = (error*Kp);
      } else if (error = 0) {
        k = 0;
      }
      new_RPM += k;
    }
    Serial.println((String)"new RPM: "+new_RPM);
    write_duty = (new_RPM/max_RPM)*255;
    analogWrite(motor_gate_pin, write_duty);
    Serial.println((String)"Duty cycle set to: "+write_duty);

    unsigned long new_current_time = millis();
    // tachnometer frequency formula: f = # pulses / time passed
    // the number of pulses is tracked by the comparator_counter variable
    // the time passed will be about the same everytime, determined by the comparator_sample_interval global variable
    comparator_time_delta = new_current_time - comparator_time_previous; // this value will be the "time passed"
    if (comparator_time_delta > comparator_sample_interval) {
      float comparator_counter_current = comparator_counter;
      float comparator_counter_delta = comparator_counter_current - comparator_counter_previous; // this value will be the "# pulses"
      float time_passed = comparator_time_delta / 1000; // to convert to seconds
      frequency = comparator_counter_delta / time_passed; // this value is "f"

      // tachometer frequency (f) to RPM formula: RPM = (f * 60) / PPR
      // where PPR = pulses per revolution
      // in the case of our centrifuge, the PPR = 2, because there are 2 light blockers, meaning that there will be two "pulses" per revolution
      angular_velocity = (frequency*60) / PPR;
      // angular_velocity = 60.0 * 1000 * comparator_counter_delta / counts_per_rev / comparator_time_delta; // rpm
      comparator_counter_previous = comparator_counter_current;
      comparator_time_previous = new_current_time;
      Serial.println((String)"Ang. Vel.: "+angular_velocity);
      Serial.println((String)"comparator counter delta: "+comparator_counter_delta);

      measured_RPM = angular_velocity;
      Serial.println((String)"Measured RPM: "+measured_RPM);
    }
    current_time = new_current_time;
  }
}
